declare enum ActionTypes {
    Authenticate = "AUTHENTICATE",
    Authorize = "AUTHORIZE",
    EndSession = "END_SESSION",
    Logout = "LOGOUT",
    ExchangeToken = "EXCHANGE_TOKEN",
    RefreshToken = "REFRESH_TOKEN",
    ResumeAuthenticate = "RESUME_AUTHENTICATE",
    RevokeToken = "REVOKE_TOKEN",
    StartAuthenticate = "START_AUTHENTICATE",
    UserInfo = "USER_INFO"
}

/**
 * Types of callbacks directly supported by the SDK.
 */
declare enum CallbackType {
    BooleanAttributeInputCallback = "BooleanAttributeInputCallback",
    ChoiceCallback = "ChoiceCallback",
    ConfirmationCallback = "ConfirmationCallback",
    DeviceProfileCallback = "DeviceProfileCallback",
    HiddenValueCallback = "HiddenValueCallback",
    KbaCreateCallback = "KbaCreateCallback",
    MetadataCallback = "MetadataCallback",
    NameCallback = "NameCallback",
    NumberAttributeInputCallback = "NumberAttributeInputCallback",
    PasswordCallback = "PasswordCallback",
    PollingWaitCallback = "PollingWaitCallback",
    ReCaptchaCallback = "ReCaptchaCallback",
    RedirectCallback = "RedirectCallback",
    SelectIdPCallback = "SelectIdPCallback",
    StringAttributeInputCallback = "StringAttributeInputCallback",
    SuspendedTextOutputCallback = "SuspendedTextOutputCallback",
    TermsAndConditionsCallback = "TermsAndConditionsCallback",
    TextInputCallback = "TextInputCallback",
    TextOutputCallback = "TextOutputCallback",
    ValidatedCreatePasswordCallback = "ValidatedCreatePasswordCallback",
    ValidatedCreateUsernameCallback = "ValidatedCreateUsernameCallback"
}
//# sourceMappingURL=enums.d.ts.map

/**
 * Base class for authentication tree callback wrappers.
 */
declare class FRCallback {
    payload: Callback;
    /**
     * @param payload The raw payload returned by OpenAM
     */
    constructor(payload: Callback);
    /**
     * Gets the name of this callback type.
     */
    getType(): CallbackType;
    /**
     * Gets the value of the specified input element, or the first element if `selector` is not
     * provided.
     *
     * @param selector The index position or name of the desired element
     */
    getInputValue(selector?: number | string): unknown;
    /**
     * Sets the value of the specified input element, or the first element if `selector` is not
     * provided.
     *
     * @param selector The index position or name of the desired element
     */
    setInputValue(value: unknown, selector?: number | string | RegExp): void;
    /**
     * Gets the value of the specified output element, or the first element if `selector`
     * is not provided.
     *
     * @param selector The index position or name of the desired element
     */
    getOutputValue(selector?: number | string): unknown;
    /**
     * Gets the value of the first output element with the specified name or the
     * specified default value.
     *
     * @param name The name of the desired element
     */
    getOutputByName<T>(name: string, defaultValue: T): T;
    private getArrayElement;
}
//# sourceMappingURL=index.d.ts.map

type FRCallbackFactory = (callback: Callback) => FRCallback;//# sourceMappingURL=factory.d.ts.map

interface Tokens {
    accessToken: string;
    idToken?: string;
    refreshToken?: string;
    tokenExpiry?: number;
}
//# sourceMappingURL=interfaces.d.ts.map

interface Action {
    type: ActionTypes;
    payload: any;
}
/**
 * Configuration options.
 */
interface ConfigOptions {
    callbackFactory?: FRCallbackFactory;
    clientId?: string;
    middleware?: RequestMiddleware[];
    realmPath?: string;
    redirectUri?: string;
    scope?: string;
    serverConfig?: ServerConfig;
    tokenStore?: TokenStoreObject | 'sessionStorage' | 'localStorage';
    tree?: string;
    type?: string;
    oauthThreshold?: number;
}
/**
 * Optional configuration for custom paths for actions
 */
interface CustomPathConfig {
    authenticate?: string;
    authorize?: string;
    accessToken?: string;
    endSession?: string;
    userInfo?: string;
    revoke?: string;
    sessions?: string;
}
type RequestMiddleware = (req: RequestObj, action: Action, next: () => RequestObj) => void;
interface RequestObj {
    url: URL;
    init: RequestInit;
}
/**
 * Configuration settings for connecting to a server.
 */
interface ServerConfig {
    baseUrl: string;
    paths?: CustomPathConfig;
    timeout?: number;
}
/**
 * API for implementing a custom token store
 */
interface TokenStoreObject {
    get: (clientId: string) => Promise<Tokens>;
    set: (clientId: string, token: Tokens) => Promise<void>;
    remove: (clientId: string) => Promise<void>;
}//# sourceMappingURL=interfaces.d.ts.map

/**
 * Represents the authentication tree API callback schema.
 */
interface Callback {
    _id?: number;
    input?: NameValue[];
    output: NameValue[];
    type: CallbackType;
}
/**
 * Represents a name/value pair found in an authentication tree callback.
 */
interface NameValue {
    name: string;
    value: unknown;
}
//# sourceMappingURL=interfaces.d.ts.map

/** ****************************************************************
 * This contains a few types pulled from the JavaScript SDK
 * TODO: Refactor the SDK to use these shared types instead of the internal ones
 */

/** ****************************************************************
 * This is the foundational config type for the Token Vault overall
 */
type BaseConfig = {
    app: {
        origin: string;
    };
    events?: Partial<EventsConfig>;
    forgerock: ForgeRockConfig;
    interceptor: {
        file: string;
        type?: 'classic' | 'module';
        scope?: string;
    };
    proxy: {
        id?: string;
        origin: string;
        path?: string;
        redact?: ('access_token' | 'refresh_token' | 'id_token')[];
    };
};
/** ****************************************************************
 * The events configuration object
 * We're going to make all props required, but allow call-sites to
 * use Partial<EventsConfig> to make props optional
 */
type EventsConfig = {
    fetch: string;
    has: string;
    refresh: string;
    remove: string;
    set: string;
};
/** ****************************************************************
 * Overriding the serverConfig prop to make it & baseUrl required,
 * rather than optional
 *
 * Use type intersection to make the serverConfig prop required
 */
interface FRConfig {
    serverConfig: {
        baseUrl: string;
    };
}
type ForgeRockConfig = FRConfig & ConfigOptions;
/** ****************************************************************
 * Convert the BaseConfig to all optional. Then, modify the result
 * specifically for the Proxy's config needs.
 */
type ProxyConfigInit = Partial<BaseConfig>;
interface ProxyConfig extends ProxyConfigInit {
    app: BaseConfig['app'];
    forgerock: BaseConfig['forgerock'];
    proxy?: BaseConfig['proxy'];
}

interface InterceptorConfig {
    events?: BaseConfig['events'];
    forgerock: ForgeRockConfig;
    interceptor: {
        urls: string[];
    };
}

/// <reference lib="webworker" />

/** ****************************************************************
 * @function interceptor - Sets up the Token Vault Intercept to intercept configured fetch requests
 * and send them to the Token Vault Proxy for adding the access token to the request.
 * @param {InterceptorConfig} config - The configuration object for the interceptor
 * @returns {void}
 * @example interceptor({
 *    forgerock: {
 *      serverConfig: {
 *        baseUrl: 'https://openam.forgerock.com/am',
 *      },
 *    },
 *    interceptor: {
 *      urls: ['https://example.com/path', 'https://alt.example.com/*'],
 *    },
 * });
 */
declare function interceptor$1(config: InterceptorConfig): void;

type ClientInit = {
    interceptor: (options?: BaseConfig['interceptor']) => Promise<ServiceWorkerRegistration | undefined>;
    proxy: (target: HTMLElement, options?: BaseConfig) => Promise<HTMLIFrameElement>;
    store: () => {
        get: (clientId: string) => Promise<Tokens>;
        set: (clientId: string, token: Tokens) => Promise<void>;
        remove: (clientId: string) => Promise<void>;
        has: () => Promise<{
            hasTokens: boolean;
        }>;
        refresh: () => Promise<{
            refreshTokens: boolean;
        }>;
    };
};

type ClientConfigInit = Partial<BaseConfig>;
interface ClientConfig extends ClientConfigInit {
    app: BaseConfig['app'];
    forgerock?: BaseConfig['forgerock'];
    interceptor: BaseConfig['interceptor'];
    proxy: BaseConfig['proxy'];
}
/** ****************************************************************
 * @function client - Initialize the Token Vault Client
 * @param {Object} config - The configuration object for the client
 * @returns {}
 * @example const register = client({
 *   app: {
 *     origin: 'http://app.example.com',
 *     url: 'http://app.example.com/path',
 *   },
 *   forgerock: {
 *     serverConfig: {
 *       baseUrl: 'https://openam.forgerock.com/am',
 *     }]
 *   },
 *   interceptor: {
 *     file: 'http://app.example.com/path/interceptor.js',
 *     scope: '/',
 *   },
 *   proxy: {
 *     origin: 'http://proxy.example.com',
 *     url: 'http://proxy.example.com/path',
 *   },
 * });
 */
declare function client$1(config: ClientConfig): ClientInit;

/** ****************************************************************
 * @function proxy - Initialize the Token Vault Proxy
 * @param {ProxyConfig} config - The configuration object for the proxy
 * @returns {void}
 * @example proxy({
 *   forgerock: { ... },
 *   app: { ... },
 *   proxy: { ... }
 * });
 */
declare function proxy$1(config: ProxyConfig): void;

declare const client: typeof client$1;
declare const interceptor: typeof interceptor$1;
declare const proxy: typeof proxy$1;

export { client, interceptor, proxy };
