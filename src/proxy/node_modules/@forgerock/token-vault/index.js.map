{"version":3,"sources":["../../../packages/token-vault/src/index.ts","../../../shared/network/src/lib/network.utilities.ts","../../../shared/workers/src/lib/worker.utilities.ts","../../../shared/workers/src/lib/interceptor.ts","../../../packages/token-vault/src/lib/client.ts","../../../packages/token-vault/src/lib/token.utils.ts","../../../packages/token-vault/src/lib/proxy.ts"],"sourcesContent":["import { interceptor as interceptorModule } from '@shared/workers';\r\nimport { client as clientModule } from './lib/client';\r\nimport { proxy as proxyModule } from './lib/proxy';\r\n\r\nexport const client = clientModule;\r\nexport const interceptor = interceptorModule;\r\nexport const proxy = proxyModule;\r\n","/// reference libs=\"WebWorker\"\r\nimport { ConfigOptions } from '@forgerock/javascript-sdk';\r\nimport { ConfigurablePaths, CustomPathConfig } from '@shared/types';\r\nimport type { RequestHeaders, ResponseClone, ResponseHeaders } from './network.types';\r\n\r\n/** ****************************************************************\r\n * @function checkForMissingSlash\r\n * @param {string} url - The URL to check for a missing slash\r\n * @returns {string} - The URL with a slash appended to the end if it was missing\r\n */\r\nexport function checkForMissingSlash(url: string) {\r\n  if (url && url.charAt(url.length - 1) !== '/') {\r\n    return url + '/';\r\n  }\r\n  return url;\r\n}\r\n\r\n/** ****************************************************************\r\n * @function cloneResponse - Clone a response\r\n * @param {Response} response - The response to clone\r\n * @returns {Promise<ResponseClone>} - The cloned response\r\n */\r\nexport async function cloneResponse(response: Response): Promise<ResponseClone> {\r\n  // Clone and redact the response\r\n  const clone = response.clone();\r\n\r\n  let body;\r\n  try {\r\n    body = await getBodyJsonOrText(clone);\r\n  } catch (error) {\r\n    // Leave body undefined\r\n  }\r\n\r\n  return {\r\n    // Conditionally set the body property\r\n    ...(body && { body }),\r\n    headers: getResponseHeaders(clone),\r\n    ok: clone.ok,\r\n    redirected: clone.redirected,\r\n    status: clone.status,\r\n    statusText: clone.statusText,\r\n    type: clone.type,\r\n    url: clone.url,\r\n  };\r\n}\r\n\r\n/** ****************************************************************\r\n * @function createErrorResponse - Create an error response\r\n * @param {string} type - The type of error\r\n * @param {Error} error - The error object\r\n * @returns {Object} - An error response object\r\n */\r\nexport function createErrorResponse(\r\n  type: 'fetch_error' | 'no_tokens' | 'refresh_error',\r\n  error: unknown,\r\n) {\r\n  const message = error instanceof Error ? error.message : 'Unknown error';\r\n\r\n  return {\r\n    body: {\r\n      error: type,\r\n      message: message,\r\n    },\r\n    headers: { 'content-type': 'application/json' },\r\n    ok: false,\r\n    redirected: false,\r\n    type: 'error',\r\n    /**\r\n     * Using the status code of 0 to indicate an opaque network error\r\n     * error without a server response.\r\n     *\r\n     * https://fetch.spec.whatwg.org/#concept-network-error\r\n     */\r\n    status: 400,\r\n    statusText: 'Token Vault Proxy Error',\r\n  };\r\n}\r\n\r\n/** ****************************************************************\r\n * @function evaluateUrlForInterception - Evaluate a URL to see if it should be intercepted\r\n * @param {string} url - The URL to evaluate\r\n * @param {string[]} urls - The URLs to check against\r\n * @returns {boolean} - Whether or not the URL should be intercepted\r\n */\r\nexport function evaluateUrlForInterception(url: string, urls: string[]) {\r\n  // Loop through the urls and check if the url matches\r\n  for (const u of urls) {\r\n    // If the url ends with a * then check if the url starts with the prefix\r\n    if (u.endsWith('*')) {\r\n      // Remove the * from the end of the url\r\n      const prefix = u.slice(0, -1);\r\n      // Check if the url starts with the prefix\r\n      if (url.startsWith(prefix)) {\r\n        return true;\r\n      }\r\n    }\r\n    // Do full URL matching\r\n    if (url.includes(u)) {\r\n      return true;\r\n    }\r\n  }\r\n  // No match\r\n  return false;\r\n}\r\n\r\n/** ****************************************************************\r\n * @function generateAmUrls - Generate the URLs for interception\r\n * @param forgerockConfig - The ForgeRock config object\r\n * @returns {Object} - An object containing the URLs for interception\r\n */\r\nexport function generateAmUrls(forgerockConfig: ConfigOptions) {\r\n  const baseUrl = checkForMissingSlash(forgerockConfig?.serverConfig?.baseUrl || '');\r\n  const realmPath = forgerockConfig?.realmPath || 'root';\r\n\r\n  return {\r\n    accessToken: `${resolveUrl(baseUrl, getEndpointPath('accessToken', realmPath))}`,\r\n    revoke: `${resolveUrl(baseUrl, getEndpointPath('revoke', realmPath))}`,\r\n    session: `${resolveUrl(baseUrl, getEndpointPath('endSession', realmPath))}?`,\r\n    userInfo: `${resolveUrl(baseUrl, getEndpointPath('userInfo', realmPath))}`,\r\n  };\r\n}\r\n\r\n/** ****************************************************************\r\n * @function getBaseUrl - Get the base URL from a URL\r\n * Returns the base URL including protocol, hostname and any non-standard port.\r\n * The returned URL does not include a trailing slash.\r\n * @param {string} url - The URL to get the base URL from\r\n * @returns {string} - The base URL\r\n */\r\nexport function getBaseUrl(url: URL) {\r\n  const isNonStandardPort =\r\n    (url.protocol === 'http:' && ['', '80'].indexOf(url.port) === -1) ||\r\n    (url.protocol === 'https:' && ['', '443'].indexOf(url.port) === -1);\r\n  const port = isNonStandardPort ? `:${url.port}` : '';\r\n  const baseUrl = `${url.protocol}//${url.hostname}${port}`;\r\n  return baseUrl;\r\n}\r\n\r\n/**\r\n * @function getResponseBodyBlob - Get the response's body blob\r\n * @param {Response} response - The response to get the body\r\n * @returns {Promise<undefined | Blob>} - The response body blob\r\n */\r\nexport async function getResponseBodyBlob(response: Response) {\r\n  const blob = await response.clone().blob();\r\n\r\n  if (blob && blob.size) {\r\n    return blob;\r\n  }\r\n  return;\r\n}\r\n\r\n/**\r\n * @function getRequestBodyBlob - Get the request's body blob\r\n * @param {Request} request - The request to get the body blob from\r\n * @returns {Promise<undefined | Blob>} - The request body blob\r\n */\r\nexport async function getRequestBodyBlob(request: Request): Promise<undefined | Blob> {\r\n  // Return undefined early if GET or HEAD\r\n  if (['GET', 'HEAD'].includes(request.method)) {\r\n    return;\r\n  }\r\n\r\n  const blob = await request.clone().blob();\r\n\r\n  if (blob && blob.size) {\r\n    return blob;\r\n  }\r\n  return;\r\n}\r\n\r\n/** ****************************************************************\r\n * @function getResponseHeaders - Get the response headers\r\n * @param {Response} response - The response to get the headers from\r\n * @returns {ResponseHeaders} - The response headers\r\n */\r\nexport function getResponseHeaders(response: Response) {\r\n  return Array.from(response.headers.keys()).reduce<ResponseHeaders>((acc, key: string) => {\r\n    acc[key] = response.headers.get(key);\r\n    return acc;\r\n  }, {});\r\n}\r\n\r\n/**\r\n * @function getRequestHeaders - Get the request headers\r\n * @param {Request} request - The request to get the headers from\r\n * @returns {RequestHeaders} - The request headers\r\n */\r\nexport function getRequestHeaders(request: Request) {\r\n  return Array.from(request.headers.keys()).reduce<RequestHeaders>((acc, key) => {\r\n    acc[key] = request.headers.get(key);\r\n    return acc;\r\n  }, {});\r\n}\r\n\r\n/** ****************************************************************\r\n * @function getBodyJsonOrText - Get the response body as JSON or text\r\n * @param {Response} response - The response to get the body from\r\n * @returns {Promise<unknown>} - The response body as JSON or text\r\n */\r\nexport async function getBodyJsonOrText(response: Response) {\r\n  const contentType = response.headers.get('Content-Type');\r\n  if (contentType && contentType.indexOf('application/json') > -1) {\r\n    return await response.json();\r\n  }\r\n  return await response.text();\r\n}\r\n\r\n/** ****************************************************************\r\n * @function getEndpointPath - Get the endpoint path\r\n * @param {ConfigurablePaths} endpoint - The endpoint to get the path for\r\n * @param {string} realmPath - The realm path\r\n * @param {CustomPathConfig} customPaths - The custom paths\r\n * @returns {string} - The endpoint path\r\n */\r\nexport function getEndpointPath(\r\n  endpoint: ConfigurablePaths,\r\n  realmPath?: string,\r\n  customPaths?: CustomPathConfig,\r\n): string {\r\n  const realmUrlPath = getRealmUrlPath(realmPath);\r\n  const defaultPaths = {\r\n    authenticate: `json/${realmUrlPath}/authenticate`,\r\n    authorize: `oauth2/${realmUrlPath}/authorize`,\r\n    accessToken: `oauth2/${realmUrlPath}/access_token`,\r\n    endSession: `oauth2/${realmUrlPath}/connect/endSession`,\r\n    userInfo: `oauth2/${realmUrlPath}/userinfo`,\r\n    revoke: `oauth2/${realmUrlPath}/token/revoke`,\r\n    sessions: `json/${realmUrlPath}/sessions/`,\r\n  };\r\n  if (customPaths && customPaths[endpoint]) {\r\n    // TypeScript is not correctly reading the condition above\r\n    // It's thinking that customPaths[endpoint] may result in undefined\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore\r\n    return customPaths[endpoint];\r\n  } else {\r\n    return defaultPaths[endpoint];\r\n  }\r\n}\r\n\r\n/** ****************************************************************\r\n * @function getRealmUrlPath - Get the realm URL path\r\n * @param {string} realmPath - The realm path\r\n * @returns {string} - The realm URL path\r\n */\r\nexport function getRealmUrlPath(realmPath?: string) {\r\n  // Split the path and scrub segments\r\n  const names = (realmPath || '')\r\n    .split('/')\r\n    .map((x) => x.trim())\r\n    .filter((x) => x !== '');\r\n\r\n  // Ensure 'root' is the first realm\r\n  if (names[0] !== 'root') {\r\n    names.unshift('root');\r\n  }\r\n\r\n  // Concatenate into a URL path\r\n  const urlPath = names.map((x) => `realms/${x}`).join('/');\r\n  return urlPath;\r\n}\r\n\r\n/** ****************************************************************\r\n * @function parseQuery - Parse a query string into an object\r\n * @param {string} fullUrl - The full URL to parse\r\n * @returns {Record<string, string>} - The parsed query string\r\n */\r\nexport function parseQuery(fullUrl: string) {\r\n  const url = new URL(fullUrl);\r\n  const query: Record<string, string> = {};\r\n  url.searchParams.forEach((v, k) => (query[k] = v));\r\n  return query;\r\n}\r\n\r\n/** ****************************************************************\r\n * @function resolveUrl - Resolve a URL\r\n * @param {string} baseUrl - The base URL\r\n * @param {string} path - The path to resolve\r\n * @returns {string} - The resolved URL\r\n */\r\nexport function resolveUrl(baseUrl: string, path: string) {\r\n  // thing\r\n  const url = new URL(baseUrl);\r\n\r\n  if (path.startsWith('/')) {\r\n    return `${getBaseUrl(url)}${path}`;\r\n  }\r\n\r\n  const basePath = url.pathname.split('/');\r\n  const destPath = path.split('/').filter((x) => !!x);\r\n  const newPath = [...basePath.slice(0, -1), ...destPath].join('/');\r\n\r\n  return `${getBaseUrl(url)}${newPath}`;\r\n}\r\n\r\n/** ****************************************************************\r\n * @function stringifyQueryParams - Stringify query parameters\r\n * @param {Record<string, string>} data - The query parameters to stringify\r\n * @returns {string} - The stringified query parameters\r\n */\r\nexport function stringifyQueryParams(data: Record<string, string>) {\r\n  const pairs: string[] = [];\r\n  for (const k in data) {\r\n    if (data[k]) {\r\n      pairs.push(k + '=' + encodeURIComponent(data[k]));\r\n    }\r\n  }\r\n  return pairs.join('&');\r\n}\r\n","import {\r\n  checkForMissingSlash,\r\n  getEndpointPath,\r\n  getRequestHeaders,\r\n  getRequestBodyBlob,\r\n  resolveUrl,\r\n} from '@shared/network';\r\nimport { InterceptorConfig } from './worker.types';\r\n\r\n/** ****************************************************************\r\n * @function generateUrlsToIntercept - Generate the URLs for interception\r\n * @param {InterceptorConfig} config - The interceptor config object\r\n * @returns {string[]} - An array of URLs to intercept\r\n */\r\nexport function generateUrlsToIntercept(config: InterceptorConfig) {\r\n  const forgerockBaseUrl = checkForMissingSlash(config.forgerock.serverConfig.baseUrl);\r\n  const realmPath = config.forgerock?.realmPath || 'root';\r\n  const urls = [\r\n    ...config.interceptor.urls,\r\n    `${resolveUrl(forgerockBaseUrl, getEndpointPath('accessToken', realmPath))}`,\r\n    `${resolveUrl(forgerockBaseUrl, getEndpointPath('endSession', realmPath))}?`,\r\n    `${resolveUrl(forgerockBaseUrl, getEndpointPath('revoke', realmPath))}`,\r\n    `${resolveUrl(forgerockBaseUrl, getEndpointPath('userInfo', realmPath))}`,\r\n    `${resolveUrl(forgerockBaseUrl, getEndpointPath('sessions', realmPath))}`,\r\n  ];\r\n  return urls;\r\n}\r\n\r\n/** ****************************************************************\r\n * @function generateOptions - Generate the options for a fetch request\r\n * Unit testing this can't currently be done without adding `Request` to Jest's globals.\r\n * It may not be worth the effort to do so, as this function is very simple.\r\n * Plus, getRequestBodyBlob is already tested in shared/network/src/utilities.test.ts, and\r\n * getRequestHeaders is already tested in shared/network/src/utilities.test.ts.\r\n * @param {Request} request - The request object\r\n * @returns {RequestInit} - The options object for the request\r\n */\r\nexport async function generateOptions(request: Request) {\r\n  return {\r\n    method: request.method,\r\n    headers: getRequestHeaders(request),\r\n    body: await getRequestBodyBlob(request),\r\n    mode: request.mode,\r\n    credentials: request.credentials,\r\n    cache: request.cache,\r\n    redirect: request.redirect,\r\n    referrer: request.referrer,\r\n    integrity: request.integrity,\r\n  };\r\n}\r\n","/// <reference lib=\"webworker\" />\r\n\r\nimport { evaluateUrlForInterception } from '@shared/network';\r\nimport type { InterceptorConfig } from './worker.types';\r\nimport { generateUrlsToIntercept, generateOptions } from './worker.utilities';\r\n\r\ndeclare const self: ServiceWorkerGlobalScope;\r\n\r\n/** ****************************************************************\r\n * @function interceptor - Sets up the Token Vault Intercept to intercept configured fetch requests\r\n * and send them to the Token Vault Proxy for adding the access token to the request.\r\n * @param {InterceptorConfig} config - The configuration object for the interceptor\r\n * @returns {void}\r\n * @example interceptor({\r\n *    forgerock: {\r\n *      serverConfig: {\r\n *        baseUrl: 'https://openam.forgerock.com/am',\r\n *      },\r\n *    },\r\n *    interceptor: {\r\n *      urls: ['https://example.com/path', 'https://alt.example.com/*'],\r\n *    },\r\n * });\r\n */\r\nexport function interceptor(config: InterceptorConfig) {\r\n  // Report back if no additional URLs are provided\r\n  if (!config.interceptor?.urls?.length) {\r\n    console.warn('No URLs provided for Token Vault interception.');\r\n  }\r\n  const fetchEventName = config?.events?.fetch || 'TVP_FETCH_RESOURCE';\r\n  const urls = generateUrlsToIntercept(config);\r\n\r\n  self.addEventListener('install', () => {\r\n    self.skipWaiting();\r\n  });\r\n  self.addEventListener('activate', (event) => {\r\n    event.waitUntil(self.clients.claim());\r\n  });\r\n\r\n  /**\r\n   * Intercept fetch requests and send them to the Token Vault Proxy\r\n   * IMPORTANT: event.respondWith must be called synchronously from this listener\r\n   */\r\n  self.addEventListener('fetch', (event) => {\r\n    const proxyChannel = new MessageChannel();\r\n    const request = event.request;\r\n    const url = event.request.url;\r\n\r\n    /**\r\n     * If the URL matches one of the URLs to intercept, send it to the Token Vault Proxy\r\n     */\r\n    if (evaluateUrlForInterception(url, urls)) {\r\n      console.log(`Intercepting ${url}`);\r\n\r\n      event.respondWith(\r\n        // eslint-disable-next-line no-async-promise-executor\r\n        new Promise(async (resolve, reject) => {\r\n          // Async code can go in here\r\n          let app;\r\n          try {\r\n            app = await self.clients.get(event.clientId);\r\n          } catch (error) {\r\n            return reject(\r\n              `Error finding client in Token Vault Interceptor (Service Worker): ${error}`,\r\n            );\r\n          }\r\n          // If no app is found, reject the promise\r\n          if (!app) {\r\n            return reject('Error finding client in Token Vault Interceptor (Service Worker)');\r\n          }\r\n          const requestCopy = {\r\n            url: request.url,\r\n            options: await generateOptions(request),\r\n          };\r\n\r\n          app.postMessage({ type: fetchEventName, request: requestCopy }, [proxyChannel.port2]);\r\n          proxyChannel.port1.onmessage = (messageEvent) => {\r\n            console.log(`Returning ${url}`);\r\n            const response = messageEvent?.data || {};\r\n\r\n            /**\r\n             * Create a new response from the response body and headers\r\n             * The body, first argument, needs to be converted back to string\r\n             */\r\n            resolve(\r\n              new Response(JSON.stringify(response?.body), {\r\n                headers: response?.headers,\r\n                status: response?.status,\r\n                statusText: response?.statusText,\r\n              }),\r\n            );\r\n          };\r\n        }),\r\n      );\r\n    }\r\n  });\r\n}\r\n","import type { Tokens } from '@forgerock/javascript-sdk';\r\nimport type { BaseConfig } from '@shared/types';\r\nimport { ClientInit } from './client.types';\r\n\r\ntype ClientConfigInit = Partial<BaseConfig>;\r\ninterface ClientConfig extends ClientConfigInit {\r\n  app: BaseConfig['app'];\r\n  forgerock?: BaseConfig['forgerock'];\r\n  interceptor: BaseConfig['interceptor'];\r\n  proxy: BaseConfig['proxy'];\r\n}\r\n\r\n/** ****************************************************************\r\n * @function client - Initialize the Token Vault Client\r\n * @param {Object} config - The configuration object for the client\r\n * @returns {}\r\n * @example const register = client({\r\n *   app: {\r\n *     origin: 'http://app.example.com',\r\n *     url: 'http://app.example.com/path',\r\n *   },\r\n *   forgerock: {\r\n *     serverConfig: {\r\n *       baseUrl: 'https://openam.forgerock.com/am',\r\n *     }]\r\n *   },\r\n *   interceptor: {\r\n *     file: 'http://app.example.com/path/interceptor.js',\r\n *     scope: '/',\r\n *   },\r\n *   proxy: {\r\n *     origin: 'http://proxy.example.com',\r\n *     url: 'http://proxy.example.com/path',\r\n *   },\r\n * });\r\n */\r\nexport function client(config: ClientConfig): ClientInit {\r\n  let tokenVaultProxyEl: HTMLIFrameElement;\r\n\r\n  return {\r\n    /** ****************************************************\r\n     * @method interceptor - Register the Token Vault Interceptor\r\n     * @param {BaseConfig['interceptor']} options - The configuration object for the interceptor\r\n     * @returns {Promise<ServiceWorkerRegistration>} - The Service Worker registration\r\n     * @example register.interceptor();\r\n     */\r\n    interceptor: async function (options?: BaseConfig['interceptor']) {\r\n      const filename = options?.file || config.interceptor.file;\r\n      const moduleType = options?.type || config?.interceptor?.type || 'module';\r\n      const scope = options?.scope || config?.interceptor?.scope || '/';\r\n\r\n      const registerServiceWorker = () => {\r\n        if ('serviceWorker' in navigator) {\r\n          try {\r\n            return navigator.serviceWorker.register(filename, {\r\n              type: moduleType,\r\n              scope: scope,\r\n            });\r\n          } catch (error) {\r\n            console.error(\r\n              `Token Vault Interceptor (Service Worker) registration failed with ${error}`,\r\n            );\r\n          }\r\n        }\r\n        return;\r\n      };\r\n\r\n      return registerServiceWorker();\r\n    },\r\n\r\n    /** ****************************************************\r\n     * @method proxy - Register the Token Vault Proxy\r\n     * @param {HTMLElement} target - The target element to append the proxy iframe to\r\n     * @param {BaseConfig['proxy']} options - The configuration object for the proxy\r\n     * @returns {Promise<HTMLIFrameElement>}\r\n     * @example register.proxy(document.getElementById('token-vault'));\r\n     */\r\n    proxy: function (target: HTMLElement, options?: BaseConfig): Promise<HTMLIFrameElement> {\r\n      const fetchEventName = config?.events?.fetch || 'TVP_FETCH_RESOURCE';\r\n      const frameId = options?.proxy?.id || config?.proxy?.id || 'token-vault-iframe';\r\n      const proxyOrigin = options?.proxy?.origin || config?.proxy.origin || 'http://localhost:9000';\r\n      const proxyUrl = options?.proxy?.path ? `${proxyOrigin}/${config?.proxy?.path}` : proxyOrigin;\r\n\r\n      const fragment = document.createElement('iframe');\r\n      fragment.setAttribute('id', frameId);\r\n      fragment.setAttribute('src', proxyUrl);\r\n      fragment.setAttribute('style', 'display: none');\r\n\r\n      tokenVaultProxyEl = target.appendChild(fragment);\r\n\r\n      console.log(`App origin: ${window.location.origin}`);\r\n      console.log(`Proxy origin: ${proxyOrigin}`);\r\n      console.log(`iframe URL: ${tokenVaultProxyEl.contentWindow?.location.href}`);\r\n\r\n      navigator.serviceWorker.addEventListener('message', (event) => {\r\n        if (event.data?.type === fetchEventName) {\r\n          tokenVaultProxyEl.contentWindow?.postMessage(\r\n            { type: fetchEventName, request: event.data.request },\r\n            proxyOrigin,\r\n            [event.ports[0]],\r\n          );\r\n        }\r\n      });\r\n\r\n      return new Promise((resolve) => {\r\n        tokenVaultProxyEl.onload = () => {\r\n          resolve(tokenVaultProxyEl);\r\n        };\r\n      });\r\n    },\r\n\r\n    /** ****************************************************\r\n     * @method store - Register the Token Vault Store\r\n     * @returns {Promise<Tokens>} - The Token Vault token store object\r\n     * @example const tokenStore = register.store();\r\n     */\r\n    store: function () {\r\n      const clientId = config?.forgerock?.clientId || 'WebOAuthClient';\r\n      const hasTokenEventName = config?.events?.has || 'TVP_HAS_TOKENS';\r\n      const refreshTokenEventName = config?.events?.refresh || 'TVP_REFRESH_TOKENS';\r\n      const removeTokenEventName = config?.events?.remove || 'TVP_REMOVE_TOKENS';\r\n\r\n      return {\r\n        /**\r\n         * @method get - A noop method that replaces the default get method\r\n         * @returns {Promise<null>}\r\n         */\r\n        get(): Promise<Tokens> {\r\n          // Tokens are not retrievable from the iframe\r\n          return Promise.resolve(null as unknown as Tokens);\r\n        },\r\n\r\n        /**\r\n         * @method has - Check if tokens exist in the Token Vault\r\n         * @returns {Promise<{ hasTokens: boolean }>} - True if tokens exist, false if not\r\n         */\r\n        has(): Promise<{ hasTokens: boolean }> {\r\n          const proxyChannel = new MessageChannel();\r\n\r\n          return new Promise((resolve) => {\r\n            tokenVaultProxyEl.contentWindow?.postMessage(\r\n              { type: hasTokenEventName, clientId },\r\n              config.proxy.origin,\r\n              [proxyChannel.port2],\r\n            );\r\n            proxyChannel.port1.onmessage = (event) => {\r\n              resolve(event.data);\r\n            };\r\n          });\r\n        },\r\n\r\n        /**\r\n         * @method refresh - Refresh tokens in the Token Vault\r\n         * @returns {Promise<{ refreshTokens: boolean }>}\r\n         */\r\n        refresh(): Promise<{ refreshTokens: boolean }> {\r\n          const proxyChannel = new MessageChannel();\r\n\r\n          return new Promise((resolve) => {\r\n            tokenVaultProxyEl.contentWindow?.postMessage(\r\n              { type: refreshTokenEventName, clientId },\r\n              config.proxy.origin,\r\n              [proxyChannel.port2],\r\n            );\r\n            proxyChannel.port1.onmessage = (event) => {\r\n              resolve(event.data);\r\n            };\r\n          });\r\n        },\r\n\r\n        /**\r\n         * @method remove - Remove tokens from the Token Vault\r\n         * @returns {Promise<void>}\r\n         */\r\n        remove(clientId: string): Promise<void> {\r\n          const proxyChannel = new MessageChannel();\r\n\r\n          return new Promise((resolve) => {\r\n            tokenVaultProxyEl.contentWindow?.postMessage(\r\n              { type: removeTokenEventName, clientId },\r\n              config.proxy.origin,\r\n              [proxyChannel.port2],\r\n            );\r\n            proxyChannel.port1.onmessage = () => {\r\n              resolve(undefined);\r\n            };\r\n          });\r\n        },\r\n\r\n        /**\r\n         * @method set - A noop method that replaces the default set method\r\n         * @param {Tokens} _ - The tokens to store\r\n         * @returns {Promise<void>}\r\n         */\r\n        set(): Promise<void> {\r\n          return Promise.resolve(undefined);\r\n        },\r\n      };\r\n    },\r\n  };\r\n}\r\n","import { ClientTokens, RefreshOAuth2TokensOptions, ServerTokens } from '@shared/types';\r\nimport { stringifyQueryParams } from '@shared/network';\r\n\r\n/** ****************************************************************\r\n * @function getTokens - Get the tokens for a client from local storage\r\n * @param {string} clientId - The client ID\r\n * @returns {ClientTokens | undefined} - The tokens for the client\r\n */\r\nexport function getTokens(clientId: string): ClientTokens | undefined {\r\n  const tokensString = localStorage.getItem(clientId);\r\n  let tokens;\r\n\r\n  if (tokensString) {\r\n    try {\r\n      tokens = JSON.parse(tokensString) || undefined;\r\n    } catch (error) {\r\n      // TODO: Handle error more intelligently\r\n    }\r\n  }\r\n\r\n  return tokens;\r\n}\r\n\r\n/** ****************************************************************\r\n * @function refreshTokens - Refresh the OAuth2 tokens for a client\r\n * @param {RefreshOAuth2TokensOptions} config - The configuration object for the refresh request\r\n * @returns {Promise<Response>} - The response from the refresh request\r\n */\r\nexport async function refreshTokens(config: RefreshOAuth2TokensOptions): Promise<Response> {\r\n  const requestParams = {\r\n    client_id: config.clientId || '',\r\n    grant_type: 'refresh_token',\r\n    refresh_token: config.refreshToken || '',\r\n    scope: config.scope || 'openid',\r\n  };\r\n\r\n  const body = stringifyQueryParams(requestParams);\r\n  const init = {\r\n    body,\r\n    headers: new Headers({\r\n      'Content-Length': body.length.toString(),\r\n      'Content-Type': 'application/x-www-form-urlencoded',\r\n    }),\r\n    method: 'POST',\r\n  };\r\n\r\n  const response = await fetch(config.url, init);\r\n\r\n  return response;\r\n}\r\n\r\n/** ****************************************************************\r\n * @function storeTokens - Store the tokens for a client in local storage\r\n * @param {Response} response - The response from the refresh request\r\n * @param {string} clientId - The client ID\r\n * @returns {Promise<void>} - A promise that resolves when the tokens are stored\r\n */\r\nexport async function storeTokens(response: Response, clientId: string) {\r\n  const newTokens: ServerTokens | undefined = await response.json();\r\n\r\n  if (!newTokens) {\r\n    throw new Error('No tokens found in response');\r\n  }\r\n\r\n  let tokenExpiry: number | undefined;\r\n  if (newTokens.expires_in) {\r\n    tokenExpiry = Date.now() + newTokens.expires_in * 1000;\r\n  }\r\n\r\n  const clientTokens: ClientTokens = {\r\n    accessToken: newTokens.access_token,\r\n    idToken: newTokens.id_token,\r\n    refreshToken: newTokens.refresh_token,\r\n    scope: newTokens.scope,\r\n    tokenExpiry,\r\n  };\r\n  localStorage.setItem(clientId, JSON.stringify(clientTokens));\r\n}\r\n\r\n/** ****************************************************************\r\n * @function tokenExpiryWithinThreshold - Check if the token expiry is within the threshold\r\n * @param {number | undefined} oauthThreshold - The threshold for token expiry\r\n * @param {number | undefined} tokenExpiry - The expiry time for the token\r\n * @returns {boolean} - Whether the token expiry is within the threshold\r\n */\r\nexport function tokenExpiryWithinThreshold(oauthThreshold?: number, tokenExpiry?: number): boolean {\r\n  console.log(oauthThreshold);\r\n  console.log(tokenExpiry);\r\n  if (oauthThreshold && tokenExpiry) {\r\n    return tokenExpiry - oauthThreshold < Date.now();\r\n  }\r\n  return false;\r\n}\r\n","import { cloneResponse, createErrorResponse, generateAmUrls } from '@shared/network';\r\nimport { EventsConfig, ProxyConfig, ServerTokens } from '@shared/types';\r\nimport { refreshTokens, storeTokens, getTokens, tokenExpiryWithinThreshold } from './token.utils';\r\n\r\n/** ****************************************************************\r\n * @function proxy - Initialize the Token Vault Proxy\r\n * @param {ProxyConfig} config - The configuration object for the proxy\r\n * @returns {void}\r\n * @example proxy({\r\n *   forgerock: { ... },\r\n *   app: { ... },\r\n *   proxy: { ... }\r\n * });\r\n */\r\nexport function proxy(config: ProxyConfig) {\r\n  /**\r\n   * Client default configuration\r\n   */\r\n  const clientId = config.forgerock?.clientId || 'WebOAuthClient';\r\n  const clientOrigin = config.app.origin || 'http://localhost:8000';\r\n  const oauthThreshold = config.forgerock?.oauthThreshold || 30 * 1000;\r\n  const scope = config.forgerock?.scope || 'openid email';\r\n  const redactedTokens = config.proxy?.redact || ['access_token', 'refresh_token'];\r\n\r\n  /**\r\n   * Default event names\r\n   * These can be overridden in the config\r\n   */\r\n  const eventDefaults = [\r\n    { name: 'TVP_FETCH_RESOURCE', type: 'fetch' },\r\n    { name: 'TVP_HAS_TOKENS', type: 'has' },\r\n    { name: 'TVP_REFRESH_TOKENS', type: 'refresh' },\r\n    { name: 'TVP_REMOVE_TOKENS', type: 'remove' },\r\n  ] as const;\r\n\r\n  /**\r\n   * Generate the event names provided in the config or use the defaults\r\n   */\r\n  const eventsObj = eventDefaults.reduce((acc, event) => {\r\n    const eventName = config.events?.[event.type] || event.name;\r\n    acc[event.type] = eventName;\r\n    return acc;\r\n  }, {} as EventsConfig);\r\n\r\n  /**\r\n   * Generate AM URLs\r\n   */\r\n  const urls = generateAmUrls(config?.forgerock);\r\n\r\n  /**\r\n   * Create the proxy iframe\r\n   */\r\n  window.addEventListener('message', async (event) => {\r\n    const requestType = event.data?.type || '';\r\n    const responseChannel = event.ports[0];\r\n\r\n    console.log(`Received ${requestType} event from ${event.origin}`);\r\n\r\n    /** ****************************************************\r\n     * FILTER OUT ALL UNRECOGNIZED OR ERROR PRONE EVENTS\r\n     *******************************************************/\r\n\r\n    // Ignore all messages that don't come from the registered client\r\n    if (event.origin !== clientOrigin) {\r\n      return;\r\n    }\r\n\r\n    // Ignore all messages that don't have a response channel\r\n    if (!responseChannel) {\r\n      return;\r\n    }\r\n\r\n    // Ignore all message with event types that are unrecognized\r\n    if (!eventDefaults.find((item) => item.name === requestType)) {\r\n      responseChannel.postMessage({\r\n        error: 'unrecognized_event',\r\n        message: `Unrecognized event type: ${requestType}`,\r\n      });\r\n      return;\r\n    }\r\n\r\n    /** ****************************************************\r\n     * HAS TOKEN\r\n     * DO NOT RETURN THE TOKEN!\r\n     *******************************************************/\r\n    if (requestType === eventsObj.has) {\r\n      const tokens = getTokens(clientId);\r\n\r\n      // Check if the Access Token exists\r\n      // DO NOT RETURN THE TOKEN ITSELF! ONLY RETURN TRUE/FALSE!\r\n      const hasTokens = Boolean(tokens?.accessToken);\r\n      responseChannel.postMessage({ hasTokens });\r\n\r\n      return;\r\n    }\r\n\r\n    /** ****************************************************\r\n     * REFRESH TOKEN\r\n     *******************************************************/\r\n    if (requestType === eventsObj.refresh) {\r\n      const tokens = getTokens(clientId);\r\n\r\n      if (!tokens?.refreshToken) {\r\n        responseChannel.postMessage({\r\n          error: 'no_tokens',\r\n          message: 'No OAuth/OIDC tokens to refresh',\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      try {\r\n        const response = await refreshTokens({\r\n          clientId,\r\n          refreshToken: tokens.refreshToken,\r\n          scope,\r\n          url: urls.accessToken,\r\n        });\r\n\r\n        // Check for error and build error message\r\n        if (!response.ok) {\r\n          // Only read json on response if not ok\r\n          const errorResponse = await response.json();\r\n          let errorMessage;\r\n          if (errorResponse?.error === 'invalid_grant') {\r\n            // \"invalid_grant\" usually means expired or invalid refresh token\r\n            errorMessage = 'Invalid or expired refresh token';\r\n          } else {\r\n            errorMessage = errorResponse?.error;\r\n          }\r\n          throw new Error(errorMessage);\r\n        }\r\n        storeTokens(response, clientId);\r\n\r\n        responseChannel.postMessage({ refreshTokens: true });\r\n\r\n        return;\r\n      } catch (error) {\r\n        // Something went wrong, remove tokens and return error\r\n        localStorage.removeItem(clientId);\r\n        responseChannel.postMessage({\r\n          error: 'refresh_error',\r\n          message: error instanceof Error ? error.message : 'Error refreshing tokens',\r\n        });\r\n\r\n        return;\r\n      }\r\n    }\r\n\r\n    /** ****************************************************\r\n     * REMOVE TOKENS\r\n     *******************************************************/\r\n    if (requestType === eventsObj.remove) {\r\n      localStorage.removeItem(clientId);\r\n      responseChannel.postMessage({ removeToken: true });\r\n\r\n      return;\r\n    }\r\n\r\n    /** ****************************************************\r\n     * CATCH ALL UNRECOGNIZED EVENTS\r\n     *******************************************************/\r\n    if (requestType !== eventsObj.fetch) {\r\n      responseChannel.postMessage({\r\n        error: 'unrecognized_event',\r\n        message: `Unrecognized event: ${requestType}`,\r\n      });\r\n      return;\r\n    }\r\n\r\n    /** ****************************************************\r\n     * FETCH PROTECTED RESOURCE\r\n     *******************************************************/\r\n    console.log(`Proxying ${event.data?.request?.url}`);\r\n\r\n    const request = event.data?.request || {};\r\n    const tokens = getTokens(clientId);\r\n\r\n    /** ****************************************************\r\n     * ACCESS TOKEN ENDPOINT\r\n     */\r\n    if (request.url?.includes('access_token')) {\r\n      let response;\r\n      try {\r\n        response = await fetch(request.url, {\r\n          ...request.options,\r\n          headers: new Headers({\r\n            ...request.options.headers,\r\n          }),\r\n        });\r\n      } catch (error) {\r\n        const errorResponse = createErrorResponse('fetch_error', error);\r\n        responseChannel.postMessage(errorResponse);\r\n        return;\r\n      }\r\n\r\n      const clonedResponse = await cloneResponse(response);\r\n      // Redact configured tokens from response body\r\n      if (clonedResponse.body) {\r\n        const body = clonedResponse.body as ServerTokens;\r\n        clonedResponse.body = redactedTokens.reduce<ServerTokens>((acc, token) => {\r\n          if (body[token]) {\r\n            acc[token] = 'REDACTED';\r\n          } else {\r\n            acc[token] = body[token];\r\n          }\r\n          return acc;\r\n        }, {} as ServerTokens);\r\n      }\r\n\r\n      // Store tokens in local storage\r\n      storeTokens(response, clientId);\r\n      responseChannel.postMessage(clonedResponse);\r\n\r\n      return;\r\n    }\r\n\r\n    // The remainder of events require tokens to be present\r\n    if (!tokens) {\r\n      const errorResponse = createErrorResponse(\r\n        'no_tokens',\r\n        new Error('No OAuth/OIDC tokens found'),\r\n      );\r\n      responseChannel.postMessage(errorResponse);\r\n      return;\r\n    }\r\n\r\n    /** ****************************************************\r\n     * TOKEN REVOCATION ENDPOINT\r\n     * Requires the token to be sent in the body\r\n     */\r\n    if (request.url?.includes('token/revoke')) {\r\n      const bodyString = await request.options?.body?.text();\r\n      const body = new URLSearchParams(bodyString);\r\n      body.append('token', tokens.accessToken);\r\n\r\n      let response;\r\n      try {\r\n        response = await fetch(request.url, {\r\n          ...request.options,\r\n          body,\r\n        });\r\n      } catch (error) {\r\n        const errorResponse = createErrorResponse('fetch_error', error);\r\n        responseChannel.postMessage(errorResponse);\r\n        return;\r\n      }\r\n\r\n      const clonedResponse = await cloneResponse(response);\r\n      responseChannel.postMessage(clonedResponse);\r\n      return;\r\n    }\r\n\r\n    /** ****************************************************\r\n     * END SESSION ENDPOINT\r\n     * requires the id_token_hint to be sent as a query parameter\r\n     */\r\n    if (request.url?.includes('connect/endSession')) {\r\n      const url = new URL(request.url);\r\n      url.searchParams.append('id_token_hint', tokens?.idToken);\r\n      console.log(url.toString());\r\n\r\n      let response;\r\n      try {\r\n        response = await fetch(url.toString(), request.options);\r\n      } catch (error) {\r\n        const errorResponse = createErrorResponse('fetch_error', error);\r\n        responseChannel.postMessage(errorResponse);\r\n        return;\r\n      }\r\n\r\n      const clonedResponse = await cloneResponse(response);\r\n      responseChannel.postMessage(clonedResponse);\r\n      return;\r\n    }\r\n\r\n    /** ****************************************************\r\n     * NON-UNIQUE ENDPOINTS\r\n     * All other requests require the access token to be sent\r\n     * in the Authorization header\r\n     */\r\n    let response;\r\n\r\n    /**\r\n     * CHECK ACCESS TOKEN THRESHOLD\r\n     * If Access Token is within threshold, skip to auto token refresh\r\n     */\r\n    if (!tokenExpiryWithinThreshold(oauthThreshold, tokens.tokenExpiry)) {\r\n      // Access token is outside threshold\r\n      try {\r\n        response = await fetch(request.url, {\r\n          ...request.options,\r\n          headers: new Headers({\r\n            ...request.options.headers,\r\n            authorization: `Bearer ${tokens ? tokens?.accessToken : ''}`,\r\n          }),\r\n        });\r\n      } catch (error) {\r\n        const errorResponse = createErrorResponse('fetch_error', error);\r\n        responseChannel.postMessage(errorResponse);\r\n        return;\r\n      }\r\n\r\n      /**\r\n       * SUCCESSFUL RESPONSE\r\n       * If the response is ok, just return the response\r\n       */\r\n      if (response.ok) {\r\n        const clonedResponse = await cloneResponse(response);\r\n        responseChannel.postMessage(clonedResponse);\r\n        return;\r\n      }\r\n\r\n      /**\r\n       * NON-401 ERROR RESPONSE\r\n       * If the response is NOT a 401, just return the response\r\n       */\r\n      if (response.status !== 401) {\r\n        const clonedResponse = await cloneResponse(response);\r\n        responseChannel.postMessage(clonedResponse);\r\n        return;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * ACCESS TOKEN WITHIN EXPIRY THRESHOLD OR 401 UNAUTHORIZED RESPONSE\r\n     * At this point, the response is both NOT OK and status code is 401.\r\n     * Because of this 401, try to refresh the Access Token.\r\n     * If a new Access Token is received, use it to make the request again.\r\n     * If the refresh fails, return the original response\r\n     */\r\n    let newTokenResponse: Response;\r\n    try {\r\n      newTokenResponse = await refreshTokens({\r\n        clientId,\r\n        refreshToken: tokens.refreshToken,\r\n        scope,\r\n        url: urls.accessToken,\r\n      });\r\n    } catch (error) {\r\n      // Remove the tokens from localStorage and return error\r\n      localStorage.removeItem(clientId);\r\n\r\n      /**\r\n       * Clone the original response if it exists\r\n       * Otherwise, create a new error response\r\n       */\r\n      const errorResponse = response\r\n        ? await cloneResponse(response)\r\n        : createErrorResponse('refresh_error', error);\r\n\r\n      const clonedResponse = errorResponse;\r\n      responseChannel.postMessage(clonedResponse);\r\n      return;\r\n    }\r\n\r\n    /**\r\n     * FAILED REFRESH RESPONSE\r\n     * If the refresh token request fails, remove the tokens from localStorage\r\n     * and return the original response.\r\n     */\r\n    if (!newTokenResponse.ok) {\r\n      localStorage.removeItem(clientId);\r\n\r\n      /**\r\n       * Clone the original response if it exists\r\n       * Otherwise, create a new error response\r\n       */\r\n      const errorResponse = response\r\n        ? await cloneResponse(response)\r\n        : createErrorResponse('fetch_error', new Error('Unable to refresh token'));\r\n\r\n      const clonedResponse = errorResponse;\r\n      responseChannel.postMessage(clonedResponse);\r\n      return;\r\n    }\r\n\r\n    let newTokens: ServerTokens | undefined;\r\n\r\n    try {\r\n      // Parse the response for the new Access Token\r\n      newTokens = await newTokenResponse.clone().json();\r\n    } catch (error) {\r\n      // leave newTokens undefined\r\n    }\r\n\r\n    /**\r\n     * ACCESS TOKEN NOT FOUND\r\n     * If a new Access Token is NOT received, remove the tokens from\r\n     * localStorage and return the original response.\r\n     */\r\n    if (!newTokens || !newTokens.access_token) {\r\n      // Remove the tokens from localStorage\r\n      localStorage.removeItem(clientId);\r\n\r\n      /**\r\n       * Clone the original response if it exists\r\n       * Otherwise, create a new error response\r\n       */\r\n      const errorResponse = response\r\n        ? await cloneResponse(response)\r\n        : createErrorResponse('fetch_error', new Error('Unable to refresh token'));\r\n      responseChannel.postMessage(errorResponse);\r\n      return;\r\n    }\r\n\r\n    /**\r\n     * SUCCESSFUL REFRESH RESPONSE\r\n     * If a new Access Token is received, store it in localStorage\r\n     */\r\n    storeTokens(newTokenResponse, clientId);\r\n\r\n    // Recall the request with the new Access Token\r\n    let newResponse: Response;\r\n    try {\r\n      // Replace the initial `response`\r\n      newResponse = await fetch(request.url, {\r\n        ...request.options,\r\n        headers: new Headers({\r\n          ...request.options.headers,\r\n          /**\r\n           * To avoid re-parsing JSON or re-reading from localStorage,\r\n           * we use the new Access Token directly from the response body.\r\n           * So, use snake_case as it's the server's format.\r\n           */\r\n          authorization: `Bearer ${newTokens.access_token}`,\r\n        }),\r\n      });\r\n    } catch (error) {\r\n      /**\r\n       * Clone the original response if it exists\r\n       * Otherwise, create a new error response\r\n       */\r\n      const errorResponse = response\r\n        ? await cloneResponse(response)\r\n        : createErrorResponse(\r\n            'fetch_error',\r\n            new Error('Unable to re-request resourse with refreshed token'),\r\n          );\r\n\r\n      responseChannel.postMessage(errorResponse);\r\n      return;\r\n    }\r\n\r\n    /**\r\n     * RE-REQUEST RESPONSE\r\n     * At this point, regardless of the response status, return the it.\r\n     */\r\n    const clonedResponse = await cloneResponse(newResponse);\r\n    responseChannel.postMessage(clonedResponse);\r\n    return;\r\n  });\r\n}\r\n"],"mappings":"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","names":["client","interceptor","proxy","_a","_b","clientId","_a","_b","_c","_d","tokens","response","clonedResponse","client","interceptor","proxy"]}