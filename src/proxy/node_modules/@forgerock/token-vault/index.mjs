// shared/network/src/lib/network.utilities.ts
function checkForMissingSlash(url) {
  if (url && url.charAt(url.length - 1) !== "/") {
    return url + "/";
  }
  return url;
}
async function cloneResponse(response) {
  const clone = response.clone();
  let body;
  try {
    body = await getBodyJsonOrText(clone);
  } catch (error) {
  }
  return {
    // Conditionally set the body property
    ...body && { body },
    headers: getResponseHeaders(clone),
    ok: clone.ok,
    redirected: clone.redirected,
    status: clone.status,
    statusText: clone.statusText,
    type: clone.type,
    url: clone.url
  };
}
function createErrorResponse(type, error) {
  const message = error instanceof Error ? error.message : "Unknown error";
  return {
    body: {
      error: type,
      message
    },
    headers: { "content-type": "application/json" },
    ok: false,
    redirected: false,
    type: "error",
    /**
     * Using the status code of 0 to indicate an opaque network error
     * error without a server response.
     *
     * https://fetch.spec.whatwg.org/#concept-network-error
     */
    status: 400,
    statusText: "Token Vault Proxy Error"
  };
}
function evaluateUrlForInterception(url, urls) {
  for (const u of urls) {
    if (u.endsWith("*")) {
      const prefix = u.slice(0, -1);
      if (url.startsWith(prefix)) {
        return true;
      }
    }
    if (url.includes(u)) {
      return true;
    }
  }
  return false;
}
function generateAmUrls(forgerockConfig) {
  var _a;
  const baseUrl = checkForMissingSlash(((_a = forgerockConfig == null ? void 0 : forgerockConfig.serverConfig) == null ? void 0 : _a.baseUrl) || "");
  const realmPath = (forgerockConfig == null ? void 0 : forgerockConfig.realmPath) || "root";
  return {
    accessToken: `${resolveUrl(baseUrl, getEndpointPath("accessToken", realmPath))}`,
    revoke: `${resolveUrl(baseUrl, getEndpointPath("revoke", realmPath))}`,
    session: `${resolveUrl(baseUrl, getEndpointPath("endSession", realmPath))}?`,
    userInfo: `${resolveUrl(baseUrl, getEndpointPath("userInfo", realmPath))}`
  };
}
function getBaseUrl(url) {
  const isNonStandardPort = url.protocol === "http:" && ["", "80"].indexOf(url.port) === -1 || url.protocol === "https:" && ["", "443"].indexOf(url.port) === -1;
  const port = isNonStandardPort ? `:${url.port}` : "";
  const baseUrl = `${url.protocol}//${url.hostname}${port}`;
  return baseUrl;
}
async function getRequestBodyBlob(request) {
  if (["GET", "HEAD"].includes(request.method)) {
    return;
  }
  const blob = await request.clone().blob();
  if (blob && blob.size) {
    return blob;
  }
  return;
}
function getResponseHeaders(response) {
  return Array.from(response.headers.keys()).reduce((acc, key) => {
    acc[key] = response.headers.get(key);
    return acc;
  }, {});
}
function getRequestHeaders(request) {
  return Array.from(request.headers.keys()).reduce((acc, key) => {
    acc[key] = request.headers.get(key);
    return acc;
  }, {});
}
async function getBodyJsonOrText(response) {
  const contentType = response.headers.get("Content-Type");
  if (contentType && contentType.indexOf("application/json") > -1) {
    return await response.json();
  }
  return await response.text();
}
function getEndpointPath(endpoint, realmPath, customPaths) {
  const realmUrlPath = getRealmUrlPath(realmPath);
  const defaultPaths = {
    authenticate: `json/${realmUrlPath}/authenticate`,
    authorize: `oauth2/${realmUrlPath}/authorize`,
    accessToken: `oauth2/${realmUrlPath}/access_token`,
    endSession: `oauth2/${realmUrlPath}/connect/endSession`,
    userInfo: `oauth2/${realmUrlPath}/userinfo`,
    revoke: `oauth2/${realmUrlPath}/token/revoke`,
    sessions: `json/${realmUrlPath}/sessions/`
  };
  if (customPaths && customPaths[endpoint]) {
    return customPaths[endpoint];
  } else {
    return defaultPaths[endpoint];
  }
}
function getRealmUrlPath(realmPath) {
  const names = (realmPath || "").split("/").map((x) => x.trim()).filter((x) => x !== "");
  if (names[0] !== "root") {
    names.unshift("root");
  }
  const urlPath = names.map((x) => `realms/${x}`).join("/");
  return urlPath;
}
function resolveUrl(baseUrl, path) {
  const url = new URL(baseUrl);
  if (path.startsWith("/")) {
    return `${getBaseUrl(url)}${path}`;
  }
  const basePath = url.pathname.split("/");
  const destPath = path.split("/").filter((x) => !!x);
  const newPath = [...basePath.slice(0, -1), ...destPath].join("/");
  return `${getBaseUrl(url)}${newPath}`;
}
function stringifyQueryParams(data) {
  const pairs = [];
  for (const k in data) {
    if (data[k]) {
      pairs.push(k + "=" + encodeURIComponent(data[k]));
    }
  }
  return pairs.join("&");
}

// shared/workers/src/lib/worker.utilities.ts
function generateUrlsToIntercept(config) {
  var _a;
  const forgerockBaseUrl = checkForMissingSlash(config.forgerock.serverConfig.baseUrl);
  const realmPath = ((_a = config.forgerock) == null ? void 0 : _a.realmPath) || "root";
  const urls = [
    ...config.interceptor.urls,
    `${resolveUrl(forgerockBaseUrl, getEndpointPath("accessToken", realmPath))}`,
    `${resolveUrl(forgerockBaseUrl, getEndpointPath("endSession", realmPath))}?`,
    `${resolveUrl(forgerockBaseUrl, getEndpointPath("revoke", realmPath))}`,
    `${resolveUrl(forgerockBaseUrl, getEndpointPath("userInfo", realmPath))}`,
    `${resolveUrl(forgerockBaseUrl, getEndpointPath("sessions", realmPath))}`
  ];
  return urls;
}
async function generateOptions(request) {
  return {
    method: request.method,
    headers: getRequestHeaders(request),
    body: await getRequestBodyBlob(request),
    mode: request.mode,
    credentials: request.credentials,
    cache: request.cache,
    redirect: request.redirect,
    referrer: request.referrer,
    integrity: request.integrity
  };
}

// shared/workers/src/lib/interceptor.ts
function interceptor(config) {
  var _a, _b, _c;
  if (!((_b = (_a = config.interceptor) == null ? void 0 : _a.urls) == null ? void 0 : _b.length)) {
    console.warn("No URLs provided for Token Vault interception.");
  }
  const fetchEventName = ((_c = config == null ? void 0 : config.events) == null ? void 0 : _c.fetch) || "TVP_FETCH_RESOURCE";
  const urls = generateUrlsToIntercept(config);
  self.addEventListener("install", () => {
    self.skipWaiting();
  });
  self.addEventListener("activate", (event) => {
    event.waitUntil(self.clients.claim());
  });
  self.addEventListener("fetch", (event) => {
    const proxyChannel = new MessageChannel();
    const request = event.request;
    const url = event.request.url;
    if (evaluateUrlForInterception(url, urls)) {
      console.log(`Intercepting ${url}`);
      event.respondWith(
        // eslint-disable-next-line no-async-promise-executor
        new Promise(async (resolve, reject) => {
          let app;
          try {
            app = await self.clients.get(event.clientId);
          } catch (error) {
            return reject(
              `Error finding client in Token Vault Interceptor (Service Worker): ${error}`
            );
          }
          if (!app) {
            return reject("Error finding client in Token Vault Interceptor (Service Worker)");
          }
          const requestCopy = {
            url: request.url,
            options: await generateOptions(request)
          };
          app.postMessage({ type: fetchEventName, request: requestCopy }, [proxyChannel.port2]);
          proxyChannel.port1.onmessage = (messageEvent) => {
            console.log(`Returning ${url}`);
            const response = (messageEvent == null ? void 0 : messageEvent.data) || {};
            resolve(
              new Response(JSON.stringify(response == null ? void 0 : response.body), {
                headers: response == null ? void 0 : response.headers,
                status: response == null ? void 0 : response.status,
                statusText: response == null ? void 0 : response.statusText
              })
            );
          };
        })
      );
    }
  });
}

// packages/token-vault/src/lib/client.ts
function client(config) {
  let tokenVaultProxyEl;
  return {
    /** ****************************************************
     * @method interceptor - Register the Token Vault Interceptor
     * @param {BaseConfig['interceptor']} options - The configuration object for the interceptor
     * @returns {Promise<ServiceWorkerRegistration>} - The Service Worker registration
     * @example register.interceptor();
     */
    interceptor: async function(options) {
      var _a, _b;
      const filename = (options == null ? void 0 : options.file) || config.interceptor.file;
      const moduleType = (options == null ? void 0 : options.type) || ((_a = config == null ? void 0 : config.interceptor) == null ? void 0 : _a.type) || "module";
      const scope = (options == null ? void 0 : options.scope) || ((_b = config == null ? void 0 : config.interceptor) == null ? void 0 : _b.scope) || "/";
      const registerServiceWorker = () => {
        if ("serviceWorker" in navigator) {
          try {
            return navigator.serviceWorker.register(filename, {
              type: moduleType,
              scope
            });
          } catch (error) {
            console.error(
              `Token Vault Interceptor (Service Worker) registration failed with ${error}`
            );
          }
        }
        return;
      };
      return registerServiceWorker();
    },
    /** ****************************************************
     * @method proxy - Register the Token Vault Proxy
     * @param {HTMLElement} target - The target element to append the proxy iframe to
     * @param {BaseConfig['proxy']} options - The configuration object for the proxy
     * @returns {Promise<HTMLIFrameElement>}
     * @example register.proxy(document.getElementById('token-vault'));
     */
    proxy: function(target, options) {
      var _a, _b, _c, _d, _e, _f, _g;
      const fetchEventName = ((_a = config == null ? void 0 : config.events) == null ? void 0 : _a.fetch) || "TVP_FETCH_RESOURCE";
      const frameId = ((_b = options == null ? void 0 : options.proxy) == null ? void 0 : _b.id) || ((_c = config == null ? void 0 : config.proxy) == null ? void 0 : _c.id) || "token-vault-iframe";
      const proxyOrigin = ((_d = options == null ? void 0 : options.proxy) == null ? void 0 : _d.origin) || (config == null ? void 0 : config.proxy.origin) || "http://localhost:9000";
      const proxyUrl = ((_e = options == null ? void 0 : options.proxy) == null ? void 0 : _e.path) ? `${proxyOrigin}/${(_f = config == null ? void 0 : config.proxy) == null ? void 0 : _f.path}` : proxyOrigin;
      const fragment = document.createElement("iframe");
      fragment.setAttribute("id", frameId);
      fragment.setAttribute("src", proxyUrl);
      fragment.setAttribute("style", "display: none");
      tokenVaultProxyEl = target.appendChild(fragment);
      console.log(`App origin: ${window.location.origin}`);
      console.log(`Proxy origin: ${proxyOrigin}`);
      console.log(`iframe URL: ${(_g = tokenVaultProxyEl.contentWindow) == null ? void 0 : _g.location.href}`);
      navigator.serviceWorker.addEventListener("message", (event) => {
        var _a2, _b2;
        if (((_a2 = event.data) == null ? void 0 : _a2.type) === fetchEventName) {
          (_b2 = tokenVaultProxyEl.contentWindow) == null ? void 0 : _b2.postMessage(
            { type: fetchEventName, request: event.data.request },
            proxyOrigin,
            [event.ports[0]]
          );
        }
      });
      return new Promise((resolve) => {
        tokenVaultProxyEl.onload = () => {
          resolve(tokenVaultProxyEl);
        };
      });
    },
    /** ****************************************************
     * @method store - Register the Token Vault Store
     * @returns {Promise<Tokens>} - The Token Vault token store object
     * @example const tokenStore = register.store();
     */
    store: function() {
      var _a, _b, _c, _d;
      const clientId = ((_a = config == null ? void 0 : config.forgerock) == null ? void 0 : _a.clientId) || "WebOAuthClient";
      const hasTokenEventName = ((_b = config == null ? void 0 : config.events) == null ? void 0 : _b.has) || "TVP_HAS_TOKENS";
      const refreshTokenEventName = ((_c = config == null ? void 0 : config.events) == null ? void 0 : _c.refresh) || "TVP_REFRESH_TOKENS";
      const removeTokenEventName = ((_d = config == null ? void 0 : config.events) == null ? void 0 : _d.remove) || "TVP_REMOVE_TOKENS";
      return {
        /**
         * @method get - A noop method that replaces the default get method
         * @returns {Promise<null>}
         */
        get() {
          return Promise.resolve(null);
        },
        /**
         * @method has - Check if tokens exist in the Token Vault
         * @returns {Promise<{ hasTokens: boolean }>} - True if tokens exist, false if not
         */
        has() {
          const proxyChannel = new MessageChannel();
          return new Promise((resolve) => {
            var _a2;
            (_a2 = tokenVaultProxyEl.contentWindow) == null ? void 0 : _a2.postMessage(
              { type: hasTokenEventName, clientId },
              config.proxy.origin,
              [proxyChannel.port2]
            );
            proxyChannel.port1.onmessage = (event) => {
              resolve(event.data);
            };
          });
        },
        /**
         * @method refresh - Refresh tokens in the Token Vault
         * @returns {Promise<{ refreshTokens: boolean }>}
         */
        refresh() {
          const proxyChannel = new MessageChannel();
          return new Promise((resolve) => {
            var _a2;
            (_a2 = tokenVaultProxyEl.contentWindow) == null ? void 0 : _a2.postMessage(
              { type: refreshTokenEventName, clientId },
              config.proxy.origin,
              [proxyChannel.port2]
            );
            proxyChannel.port1.onmessage = (event) => {
              resolve(event.data);
            };
          });
        },
        /**
         * @method remove - Remove tokens from the Token Vault
         * @returns {Promise<void>}
         */
        remove(clientId2) {
          const proxyChannel = new MessageChannel();
          return new Promise((resolve) => {
            var _a2;
            (_a2 = tokenVaultProxyEl.contentWindow) == null ? void 0 : _a2.postMessage(
              { type: removeTokenEventName, clientId: clientId2 },
              config.proxy.origin,
              [proxyChannel.port2]
            );
            proxyChannel.port1.onmessage = () => {
              resolve(void 0);
            };
          });
        },
        /**
         * @method set - A noop method that replaces the default set method
         * @param {Tokens} _ - The tokens to store
         * @returns {Promise<void>}
         */
        set() {
          return Promise.resolve(void 0);
        }
      };
    }
  };
}

// packages/token-vault/src/lib/token.utils.ts
function getTokens(clientId) {
  const tokensString = localStorage.getItem(clientId);
  let tokens;
  if (tokensString) {
    try {
      tokens = JSON.parse(tokensString) || void 0;
    } catch (error) {
    }
  }
  return tokens;
}
async function refreshTokens(config) {
  const requestParams = {
    client_id: config.clientId || "",
    grant_type: "refresh_token",
    refresh_token: config.refreshToken || "",
    scope: config.scope || "openid"
  };
  const body = stringifyQueryParams(requestParams);
  const init = {
    body,
    headers: new Headers({
      "Content-Length": body.length.toString(),
      "Content-Type": "application/x-www-form-urlencoded"
    }),
    method: "POST"
  };
  const response = await fetch(config.url, init);
  return response;
}
async function storeTokens(response, clientId) {
  const newTokens = await response.json();
  if (!newTokens) {
    throw new Error("No tokens found in response");
  }
  let tokenExpiry;
  if (newTokens.expires_in) {
    tokenExpiry = Date.now() + newTokens.expires_in * 1e3;
  }
  const clientTokens = {
    accessToken: newTokens.access_token,
    idToken: newTokens.id_token,
    refreshToken: newTokens.refresh_token,
    scope: newTokens.scope,
    tokenExpiry
  };
  localStorage.setItem(clientId, JSON.stringify(clientTokens));
}
function tokenExpiryWithinThreshold(oauthThreshold, tokenExpiry) {
  console.log(oauthThreshold);
  console.log(tokenExpiry);
  if (oauthThreshold && tokenExpiry) {
    return tokenExpiry - oauthThreshold < Date.now();
  }
  return false;
}

// packages/token-vault/src/lib/proxy.ts
function proxy(config) {
  var _a, _b, _c, _d;
  const clientId = ((_a = config.forgerock) == null ? void 0 : _a.clientId) || "WebOAuthClient";
  const clientOrigin = config.app.origin || "http://localhost:8000";
  const oauthThreshold = ((_b = config.forgerock) == null ? void 0 : _b.oauthThreshold) || 30 * 1e3;
  const scope = ((_c = config.forgerock) == null ? void 0 : _c.scope) || "openid email";
  const redactedTokens = ((_d = config.proxy) == null ? void 0 : _d.redact) || ["access_token", "refresh_token"];
  const eventDefaults = [
    { name: "TVP_FETCH_RESOURCE", type: "fetch" },
    { name: "TVP_HAS_TOKENS", type: "has" },
    { name: "TVP_REFRESH_TOKENS", type: "refresh" },
    { name: "TVP_REMOVE_TOKENS", type: "remove" }
  ];
  const eventsObj = eventDefaults.reduce((acc, event) => {
    var _a2;
    const eventName = ((_a2 = config.events) == null ? void 0 : _a2[event.type]) || event.name;
    acc[event.type] = eventName;
    return acc;
  }, {});
  const urls = generateAmUrls(config == null ? void 0 : config.forgerock);
  window.addEventListener("message", async (event) => {
    var _a2, _b2, _c2, _d2, _e, _f, _g, _h, _i;
    const requestType = ((_a2 = event.data) == null ? void 0 : _a2.type) || "";
    const responseChannel = event.ports[0];
    console.log(`Received ${requestType} event from ${event.origin}`);
    if (event.origin !== clientOrigin) {
      return;
    }
    if (!responseChannel) {
      return;
    }
    if (!eventDefaults.find((item) => item.name === requestType)) {
      responseChannel.postMessage({
        error: "unrecognized_event",
        message: `Unrecognized event type: ${requestType}`
      });
      return;
    }
    if (requestType === eventsObj.has) {
      const tokens2 = getTokens(clientId);
      const hasTokens = Boolean(tokens2 == null ? void 0 : tokens2.accessToken);
      responseChannel.postMessage({ hasTokens });
      return;
    }
    if (requestType === eventsObj.refresh) {
      const tokens2 = getTokens(clientId);
      if (!(tokens2 == null ? void 0 : tokens2.refreshToken)) {
        responseChannel.postMessage({
          error: "no_tokens",
          message: "No OAuth/OIDC tokens to refresh"
        });
        return;
      }
      try {
        const response2 = await refreshTokens({
          clientId,
          refreshToken: tokens2.refreshToken,
          scope,
          url: urls.accessToken
        });
        if (!response2.ok) {
          const errorResponse = await response2.json();
          let errorMessage;
          if ((errorResponse == null ? void 0 : errorResponse.error) === "invalid_grant") {
            errorMessage = "Invalid or expired refresh token";
          } else {
            errorMessage = errorResponse == null ? void 0 : errorResponse.error;
          }
          throw new Error(errorMessage);
        }
        storeTokens(response2, clientId);
        responseChannel.postMessage({ refreshTokens: true });
        return;
      } catch (error) {
        localStorage.removeItem(clientId);
        responseChannel.postMessage({
          error: "refresh_error",
          message: error instanceof Error ? error.message : "Error refreshing tokens"
        });
        return;
      }
    }
    if (requestType === eventsObj.remove) {
      localStorage.removeItem(clientId);
      responseChannel.postMessage({ removeToken: true });
      return;
    }
    if (requestType !== eventsObj.fetch) {
      responseChannel.postMessage({
        error: "unrecognized_event",
        message: `Unrecognized event: ${requestType}`
      });
      return;
    }
    console.log(`Proxying ${(_c2 = (_b2 = event.data) == null ? void 0 : _b2.request) == null ? void 0 : _c2.url}`);
    const request = ((_d2 = event.data) == null ? void 0 : _d2.request) || {};
    const tokens = getTokens(clientId);
    if ((_e = request.url) == null ? void 0 : _e.includes("access_token")) {
      let response2;
      try {
        response2 = await fetch(request.url, {
          ...request.options,
          headers: new Headers({
            ...request.options.headers
          })
        });
      } catch (error) {
        const errorResponse = createErrorResponse("fetch_error", error);
        responseChannel.postMessage(errorResponse);
        return;
      }
      const clonedResponse2 = await cloneResponse(response2);
      if (clonedResponse2.body) {
        const body = clonedResponse2.body;
        clonedResponse2.body = redactedTokens.reduce((acc, token) => {
          if (body[token]) {
            acc[token] = "REDACTED";
          } else {
            acc[token] = body[token];
          }
          return acc;
        }, {});
      }
      storeTokens(response2, clientId);
      responseChannel.postMessage(clonedResponse2);
      return;
    }
    if (!tokens) {
      const errorResponse = createErrorResponse(
        "no_tokens",
        new Error("No OAuth/OIDC tokens found")
      );
      responseChannel.postMessage(errorResponse);
      return;
    }
    if ((_f = request.url) == null ? void 0 : _f.includes("token/revoke")) {
      const bodyString = await ((_h = (_g = request.options) == null ? void 0 : _g.body) == null ? void 0 : _h.text());
      const body = new URLSearchParams(bodyString);
      body.append("token", tokens.accessToken);
      let response2;
      try {
        response2 = await fetch(request.url, {
          ...request.options,
          body
        });
      } catch (error) {
        const errorResponse = createErrorResponse("fetch_error", error);
        responseChannel.postMessage(errorResponse);
        return;
      }
      const clonedResponse2 = await cloneResponse(response2);
      responseChannel.postMessage(clonedResponse2);
      return;
    }
    if ((_i = request.url) == null ? void 0 : _i.includes("connect/endSession")) {
      const url = new URL(request.url);
      url.searchParams.append("id_token_hint", tokens == null ? void 0 : tokens.idToken);
      console.log(url.toString());
      let response2;
      try {
        response2 = await fetch(url.toString(), request.options);
      } catch (error) {
        const errorResponse = createErrorResponse("fetch_error", error);
        responseChannel.postMessage(errorResponse);
        return;
      }
      const clonedResponse2 = await cloneResponse(response2);
      responseChannel.postMessage(clonedResponse2);
      return;
    }
    let response;
    if (!tokenExpiryWithinThreshold(oauthThreshold, tokens.tokenExpiry)) {
      try {
        response = await fetch(request.url, {
          ...request.options,
          headers: new Headers({
            ...request.options.headers,
            authorization: `Bearer ${tokens ? tokens == null ? void 0 : tokens.accessToken : ""}`
          })
        });
      } catch (error) {
        const errorResponse = createErrorResponse("fetch_error", error);
        responseChannel.postMessage(errorResponse);
        return;
      }
      if (response.ok) {
        const clonedResponse2 = await cloneResponse(response);
        responseChannel.postMessage(clonedResponse2);
        return;
      }
      if (response.status !== 401) {
        const clonedResponse2 = await cloneResponse(response);
        responseChannel.postMessage(clonedResponse2);
        return;
      }
    }
    let newTokenResponse;
    try {
      newTokenResponse = await refreshTokens({
        clientId,
        refreshToken: tokens.refreshToken,
        scope,
        url: urls.accessToken
      });
    } catch (error) {
      localStorage.removeItem(clientId);
      const errorResponse = response ? await cloneResponse(response) : createErrorResponse("refresh_error", error);
      const clonedResponse2 = errorResponse;
      responseChannel.postMessage(clonedResponse2);
      return;
    }
    if (!newTokenResponse.ok) {
      localStorage.removeItem(clientId);
      const errorResponse = response ? await cloneResponse(response) : createErrorResponse("fetch_error", new Error("Unable to refresh token"));
      const clonedResponse2 = errorResponse;
      responseChannel.postMessage(clonedResponse2);
      return;
    }
    let newTokens;
    try {
      newTokens = await newTokenResponse.clone().json();
    } catch (error) {
    }
    if (!newTokens || !newTokens.access_token) {
      localStorage.removeItem(clientId);
      const errorResponse = response ? await cloneResponse(response) : createErrorResponse("fetch_error", new Error("Unable to refresh token"));
      responseChannel.postMessage(errorResponse);
      return;
    }
    storeTokens(newTokenResponse, clientId);
    let newResponse;
    try {
      newResponse = await fetch(request.url, {
        ...request.options,
        headers: new Headers({
          ...request.options.headers,
          /**
           * To avoid re-parsing JSON or re-reading from localStorage,
           * we use the new Access Token directly from the response body.
           * So, use snake_case as it's the server's format.
           */
          authorization: `Bearer ${newTokens.access_token}`
        })
      });
    } catch (error) {
      const errorResponse = response ? await cloneResponse(response) : createErrorResponse(
        "fetch_error",
        new Error("Unable to re-request resourse with refreshed token")
      );
      responseChannel.postMessage(errorResponse);
      return;
    }
    const clonedResponse = await cloneResponse(newResponse);
    responseChannel.postMessage(clonedResponse);
    return;
  });
}

// packages/token-vault/src/index.ts
var client2 = client;
var interceptor2 = interceptor;
var proxy2 = proxy;
export {
  client2 as client,
  interceptor2 as interceptor,
  proxy2 as proxy
};
//# sourceMappingURL=index.mjs.map